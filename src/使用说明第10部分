按顺序记录原来的心得

第1题    -两数之和（方法1暴力，方法2是添加到hashmap中后，再遍历一次出结果，方法3是在添加hashmap时就比较，从而看能不能有结果）
第2题    -两数相加（不使用虚拟头结点和使用虚拟头结点两种写法）
第3题    -无重复字符的最长子串(用set是将窗口更新后，每次窗口都会删除元素，再计算，而Map没有删除元素，而是比较元素的索引是
             否有效即是否还在窗口中。方法是滑动窗口)（没做出来）
第4题   -寻找两个有序数组的中位数（要求时间复杂度是O(log(m+n)）
            （没做出来。方法1：归并merge，将两个数组合并成一个.方法2：二分法。方法3：第k小的数 方法3比2容易理解）
第5题    -最长回文子串（没做出来）(1.暴力法，这里不推荐掌握。2.中心扩散法。3.动态规划法。4.马拉车算法 23中，2最优，整体4最优)
             这里暂时记录的3种方法，123.且1不推荐，2看懂了，也推荐掌握。3理解起来有点难度，在考场上想出来还是有难度。
Leetcode----------7. 整数反转
Leetcode----------8. 字符串转换整数 (atoi)
Leetcode----------9. 回文数(记录两个方法)       String strNum = String.valueOf(x);
第10题 -正则表达式匹配(offer上有，但是没做出来)(两种方法，1.offer上的递归，2.力扣上的动态规划。但是还是不会动态)
            O((n+m)*2^(n+m/2)) n和m分别是s和p的长度
第11题  -盛最多水的容器（共两种方法：双指针和暴力法）
Leetcode----------13. 罗马数字转整数
                                （主要是要找出几个特殊情况）
Leetcode----------14. 最长公共前缀
第15题 -三数之和（想到了先排序，再双指针，但是后续的思路没想出来）
Leetcode----------16. 最接近的三数之和
                            排序加双指针
第17题 -电话号码的数字组合（没做出来，是回溯法）(主要用回溯，其实也有其他方法)
第19题  -删除链表中倒数第n个节点（使用快慢指针，快指针比慢指针快n步，方法2：虚拟头结点 方法3：两次遍历，第一次计算长度）

第20题   -有效的括号（这里使用的hashmap+栈的做法以及只用栈的方法）
第21题   -合并两个链表（掌握这一个写法就够了）
第22题 —括号生成(思路是深度，但是coding能力不够)(本题可以深度，广度以及回溯以及动态)（这里广度只是记录解法，并没掌握）
                （solution1和2都是深度遍历，推荐掌握写法2，深度可以用栈）（solution3是广度，广度是用队列的）
第23题 -合并K个排序链表（方法1：两两合并，参考第21题 方法2：三个指针 这两个方法都是 时间复杂度：O(NK) 方法2不记录
                这里记录方法3 ：对三指针的优化 使用小根堆对 1 进行优化，每次 O(logK), 时间复杂度：O(NlogK)（优化没想到）
                   方法4：方法1实际上是逐一合并，当然可以两两合并优化，也可以叫归并吧 这里也不记录） solution3是匿名内部类
Leetcode----------24. 两两交换链表中的节点
                            （自己做出来的）
Leetcode----------25. K 个一组翻转链表（很遗憾，跳过了）
                            可以使用栈，也可以不使用额外空间，原地搞  思考再三，还是放弃，这里记录了写法，但是没掌握透彻。
Leetcode----------26. 删除排序数组中的重复项  (典型的双指针)
Leetcode----------27. 移除元素（和26及其像）
        字符串是硬伤

第31题 -下一个排列（没做出来，思路大概有一半吧，然后看官方的动画秒懂）（难就难在过程分析上，怎么理清思路）
第32题 -最长有效括号（没做出来 方法1：栈 方法2：动态规划 方法3：递归  方法4：只有两个指针变量进行更新）
            （记录的是方法1和方法4）（方法4很巧妙，左边扫一轮，去除左括号多的情况。右边扫一轮，取出右边括号多的情况）
            （仍建议使用栈的方法）
第33题 —搜索旋转排序数组。要求log(n) 所以是二分法。(没做出来)（offer书上有一个题是旋转数组的最小数字）
               怎么分，是关键
第34题 -在排序数组中查找元素的第一个和最后一个位置(由于要求logn，所以必须是二分，也只有二分)（没做出来）
            （方法1不是特别好，数据不好时会退化。方法2比较好，建议掌握）
Leetcode----------35. 搜索插入位置
                            (本题显然最优解是二分，因此记录两个写法)
36(虽然记录的代码，但是看不懂)
Leetcode----------38. 外观数列
                            （双指针递归的方法，或者用循环写也可以，还可以吧这题，值得一做）
第39题 -组合总和（没做出来）（典型的递归回溯即剪枝，以及动态规划也能解题）(这里记录的是回溯法的两个写法，是否用全局变量)
                而排序之后可以实现剪枝
40
Leetcode----------41. 缺失的第一个正数
                            （1.暴力法，不记录，2.排序后查找，3.排序后二分查找-记录，4.set集合-记录)
                            你的算法的时间复杂度应为O(n)，并且只能使用常数级别的额外空间。因此，上述方法都不符合要求
                        最好的算法，原地置换。
第42题 -接雨水（做不出来 这里提供3中方法  逐个优化，但是方法1最好理解。两个O(n) 方法2和3一个O(n)一个O(1)
                    方法2对1的优化，方法3是使用栈，或者说是单调栈，比较好用）
            这里没有完全弄懂单调栈，等看左神的视频
43
44  困难题 dp
Leetcode----------45. 跳跃游戏 II
                            难得一见的贪心
第46题 -全排列（典型的回溯，和39题很类似了）（下次碰见回溯，可以手敲了）
47
第48题 -旋转图像（offer书上的旋转数组，找到规律，下次直接敲吧，想法很正确）
第49题 -字母异位词分组（没做出来）（这里看懂了方法1，如果频率高，再来记录后面高端方法）(23比1的时间复杂度低，2又比3强点)
           （方法1：hash表，具体看代码值得一看的是coding能力，本身算法的设计并不算太惊艳。方法2：用质数相乘。方法3：用#分割）
Leetcode----------50. Pow(x, n)
                        二分递归
第53题   -最大子序和（解法1：窗口法或者叫动态规划，大佬这么叫的 解法2：分治法 建议掌握解法1，这里仅仅是收录解法2而已

Leetcode----------54. 螺旋矩阵
                            这题就是剑指offer的原题
第55题 -跳跃游戏（做不出来）(解题思路：如果我能到某个位置，那么这个位置的左边我都能到，所以我只用看最远我能到哪里)
            因此，到达某个位置后，就看当前位置+当前位置的元素，看是否能到达更远，可以，就更新，不能就到下一个位置。
            如果到达当前的最远位置，且加起来不能到达更远，则说明跳不到中点。则false
第56题 -合并区间（没做出来）（另外本题方法种类不多，不推荐掌握，本题和49题类似，后续看题频）（本题暂时驾驭不了）
57
Leetcode----------58. 最后一个单词的长度
                            从屁股开始，先去掉空格，然后再碰到空格或者越界时，就出结果了
59
Leetcode----------61. 旋转链表
第62题 -不同路径（没做出来，是最简单的动态规划）(可以有递归写法改成备忘录写法，再改成动态规划)
                （动态规划自下而上，备忘录自顶向下，记录了一次后，在用到就直接拿）
Leetcode----------63. 不同路径 II
                        注意边界  在入口和初始边界都可以放障碍
第64题 -最小路径和（稍难一点的动态规划,思路想错了，我觉得需要定义全局变量来比较，实际上不需要）（再学习几道，然后手敲）
Leetcode----------66. 加一
                        （本题解法的思想还是比较巧妙的，没有真正的进行计算）
Leetcode----------67. 二进制求和
                            （做的人很多，但是非科班不太容易理解，难顶哦，记录一个能看懂的）
Leetcode----------69. x 的平方根
                            二分法
第70题 -爬楼梯（斐波那契数列的各种解法，集中在一个class中）
第72题 -编辑距离(字符串的动态规划)（有点绕，画表后仔细琢磨）
74
第75题 -颜色分类（也称荷兰国旗问题）（快排的partition函数，但是没看出来）
                （三路快排的思想,一个操作使得所有数分三块，左边都是小的，中间是等于的，右边的是大的）
第76题 -最小覆盖子串（困难题，暂时放弃）
77
第78题 -子集（没做出来）(根据题频考虑是否二刷去掌握了)
第79题 -单词搜索（没做出来）（典型的深度搜索加回溯的方法）（有人说是头条的题）（边界条件搞清楚）
80
Leetcode----------82. 删除排序链表中的重复元素 II
                        本题用虚拟头结点会好一点
Leetcode----------83. 删除排序链表中的重复元素
第84题 -柱状图中最大的矩形（困难级别 也是建议根据题频是否考虑二刷）（单调栈，和接雨水的42题比较类似，也有普通的方法）
                （如果下面还出现单调栈的题，那么单调栈需要仔细掌握了）
Leetcode----------84. 柱状图中最大的矩形
                        本题的单调栈有难度
86
Leetcode----------88. 合并两个有序数组
                            （同面试金典1001）
90
Leetcode----------91. 解码方法
                            本题太恶心的就是边界，很不好调试。可以先放弃。
                            参考剑指offer第46题，本题多一个0的边界，所以特别复杂，其实递推就比较简单
Leetcode----------92. 反转链表 II
                            有点难顶哦，写法和206还是有区别的
Leetcode----------94. 二叉树的中序遍历
Leetcode----------96. 不同的二叉搜索树
                                （懂的就懂，不懂的就不懂,这道题意义不大）
Leetcode----------98. 验证二叉搜索树
                            2个写法，中序递归的时候直接比，或者中序的时候用数组存，然后逐个比。
                            那么这里问一句，你的中序非递归会写不。因此记录了3个写法。 中序提供了非递归
Leetcode 100  -----相同的树(递归自己做出来的)（当然可以有其他的非递归写法，就是遍历一个节点比较一次。层序和深度均可以）
                        (就是所有的遍历写法都可以，只是加上值的比较)（这里是只记录了递归和深度遍历非递归）
                        （我改写的可能不健壮
                        参考剑指offer第28题，可能需要加几行代码）
Leetcode 101  -----对称二叉树 （本题是镜像二叉树 和剑指offer28题一样  判断树是否对称  而剑指offer27则是反转二叉树）
                            (本题又是个return中几个一起的，因为是子问题加根都要满足条件，所以并列）(3个方法)
                            （注意还有非递归的写法  并且虽然只记录了栈，其实也可以用队列 ）（本题新增加记录了队列方法）
Leetcode----------102. 二叉树的层序遍历
                            最基础的层序(自己写出来了)
Leetcode----------103. 二叉树的锯齿形层次遍历
                            (之字形打印二叉树) 同样根据层次遍历的写法，有两个写法
Leetcode 104   -------二叉树的深度(同剑指offer第27题)（本题的队列写法和27题中记录的不同）
106
Leetcode 107   ------二叉树的层次遍历 II（和剑指offer32-2题，104题类似。一个从上到下，一个从下到上）（只不过要反转一下）
                        （考虑链表的反转或者数组的反转，可以使用的是头插法，链表的翻转写法，以及栈的使用，这里记录了一种用栈
                        的方法，其实考虑层次遍历的写法都不止一种，如32-2中的记录两个写法都可以改变成其他写法）
Leetcode 108  -------将有序数组转换为二叉搜索树(同面试金典04.02)（本次的边界条件和金典中记录的不同，是根据我的习惯的边界）
Leetcode 110  -----平衡二叉树（同面试金典0404 同剑指offer 55-2）（代码直接拷过来了）
Leetcode 111  ----- 二叉树的最小深度(直接从最大深度改为Min容易翻车 翻车案例[1,2]的深度是2不是1)（因此需要添加一下判断条件）
Leetcode 112  -----路径总和(递归好写，迭代不好写，需要在栈中压入当前的sum。)（我记录的solution2是不能通过的示例）
113  同剑指offer34
114  和剑指offer36题不同 36题是双向链表，并且是按照中序来排的，而114是前序的顺序   递归记录的是后序拼接  记下solution2
116
Leetcode----------118. 杨辉三角
                                可以用dp
119   倒着加，本题能让你学会空间压缩  正着来，需要一个变量记录之前的数据.
Leetcode----------120. 三角形最小路径和
                            dp[i][j] = Math.min(dp[i+1][j], dp[i+1][j+1]) + curTr.get(j);
                            压缩的写法（考场上做出来就行？压缩的需要进阶的）
                            dp[j] = Math.min(dp[j],dp[j+1]) + curTr.get(j);
第121题  -买卖股票的最佳时机(这里的方法比较类似于滑动窗口)
Leetcode----------122. 买卖股票的最佳时机 II
                         思路1，赚到钱就卖，思路2，持有股票和不持有股票两个状态。
Leetcode----------125. 验证回文串
                            (自己敲出来的)
Leetcode----------128. 最长连续序列
                            两个方法，排序然后比较，或者hash，然后更新长度
129
130  可以看到，图 深度是递归  广度是队列，很少看到用栈的。
Leetcode----------136. 只出现一次的数字
                            异或同一个数两次，原数不变。  或者用hashset  另外的思路，排序后两两比较（剑指offer中也有这题）
139  实际上，本题下次直接跳过，除非出现在面经
Leetcode----------141. 环形链表
                            2个写法（Set保持节点，而不是节点的值，方法2，快慢指针）
Leetcode----------142. 环形链表 II
                        剑指offer也有，建议背最优，推导见牛客博客。当然可以有hash表的方法
143  字节跳动的题， 这里记录两个方法。 翻转的和用list存的。
Leetcode----------144. 二叉树的前序遍历
Leetcode----------145. 二叉树的后序遍历
                            应该注意博客中记录的方法。
Leetcode----------146. LRU缓存机制（最近最少使用，对于使用最早的，给予删除，给新来的腾地方）
147
148  超级重点  归并和快排
Leetcode----------151. 翻转字符串里的单词
                            （这类题剑指offer也有，思路是反转两次，讲真，力扣上大都是api大神）
                            （这里改成了最终版）
Leetcode----------152. 乘积最大子数组
                        2个方法，比较巧妙
153 二分
Leetcode----------155. 最小栈
                            （剑指offer的包含min函数的栈）实际上使用了一个辅助栈，用来存最小数值
                            我牛客上记录了两个方式，这里只记录了一个，注意回去看牛客的。
Leetcode----------160. 相交链表
                                拼接成两个链表，或者是做链表的长度差，然后再跑一遍，其本质是一样的。
Leetcode----------167. 两数之和 II - 输入有序数组
                            明显的双指针
第169题 -多数元素（offer上第39题，先排序，再求中间值，这样时间复杂度O(N*logN)。本题是肯定有解，所以难度比offer低）
             （方法1：排序后取中间。方法2.HashMap。方法3：投票法（超过一半减去其他人的票后还是正数） 方法4：快排的partition）
             这里建议面试使用方法3 最佳。方法1和方法4也就是要掌握快排，方法2也不难（没做出来）复杂度是ologn,n,n,n。
171
Leetcode----------189. 旋转数组
                        方法比较多.(典型的copy一个数组，然后改值)（不使用额外的空间，就和那种英文单词句子反转一样，本题也是
                        3次翻转）
191
Leetcode----------198. 打家劫舍
                            (DP)本题同面试金典1716按摩师
Leetcode----------199. 二叉树的右视图
                            每一层的最优节点，层序遍历，使用队列。
Leetcode----------200. 岛屿数量
                            典型的并查集，但是不会，所以用笨方法.这里记住，深度最好写递归，广度只能是队列（记录两个方法）
                            广度有点难理解，先放着，深度一定要会的。
Leetcode----------202. 快乐数
                        本题两个方法，hashset和快慢指针
Leetcode----------203. 移除链表元素
209  记住双指针做法就行
213
Leetcode----------215. 数组中的第K个最大元素
                            重点题！！！！（剑指offer第40题是最小的K个数，这里可以拿一个专题来复习）
                            还没做完.....待后续再做
216
Leetcode----------217. 存在重复元素
                            这题是最最最基础的题了
219
Leetcode----------221. 最大正方形
                        dp
Leetcode----------225. 用队列实现栈
Leetcode 226.   -------翻转二叉树-------(同剑指offer第27题)
230
232
Leetcode----------234. 回文链表
                               在不要求空间复杂度的时候，是可以用栈的，利用快慢指针，然后慢指针和栈中元素对比
                               也可以用数组存放数字，双指针比较。
                               要求空间复杂度，则是用反转链表
Leetcode 235  -----二叉搜索树的最近公共祖先(同剑指offer68-1题 剑指用了两个方法，这里就记录一个吧)
Leetcode----------236. 二叉树的最近公共祖先
237   本题也是offer书上的18题要表达的意思   与203题遥相呼应
Leetcode----------238. 除自身以外数组的乘积
                        本题和牛客的那个从1一直乘到n的数组是一样的题
239   单调的双端队列
Leetcode----------242. 有效的字母异位词
                            桶计数
Leetcode 257  -----二叉树的所有路径(典型的深度遍历，或者说是和图的深度遍历一样，不能出现相同的元素，需要回溯)
                         （虽然说回溯有非递归写法，但一般都用递归写）（这里记录两个方法，1.不使用回溯。2.使用回溯）(没做出来)
                         （因为普通的树的深度遍历递归写法，由于字符串类型在不new对象的时候，是值传递，所以可以边遍历边添加）
                         （所以方法2中使用StringBuider时，是必须要回溯，因为改动一次后，就会一直变动）
                         （a方法中的String和StringBuilder在调用b方法修改了String和StringBuider后，返回，那么String并不会变动
                         而StringBuilder变动了，因此a可以再调到c传入的还是String，而在调c方法还想传入之前的Buider就必须回溯）
                         其中solution1提供2中写法，建议学会第二种
258
Leetcode----------264. 丑数 II
                            （本题和剑指offer的丑数题一样，没什么好方法，会做就是会做，记好方法即可）
268 方法多，但不适合面试， 位运算，hashmap等等...
Leetcode----------279. 完全平方数
                             dp[i] = Math.min(dp[i], dp[i - j * j] + 1); // 动态转移方程
Leetcode----------283. 移动零
                        （两种写法，一个是赋值，一个是交换，都是O（n），但是交换的稍微好一点）
Leetcode----------287. 寻找重复数（有点难理解，但是可以一做，需要看题频）
                            #数组只能读 所以不能排序,不能swap数组下标
                            #时间复杂度小于 O(n^2) 不能暴力
                            #空间复杂度 O(1) 不能额外开辟数组
                            这里记录的是最好的方法，和环形链表II 142题的思想比较像
292  这种题不大可能考
Leetcode----------300. 最长上升子序列
                            第2种方法，是比较牛批的，但是不容易理解，可以参考力扣里面的题解， (newhar)
                            （感觉剑指offer上有）
Leetcode----------303. 区域和检索 - 数组不可变
                            (这个题也有点闹眼子)
Leetcode----------309. 最佳买卖股票时机含冷冻期
                                （和714类似，只不过本题还多一种状态）
Leetcode----------312. 戳气球
                            (难度有点大啊)自底向上，且两边加虚拟气球，因此在戳破某个气球时，应该认为其两段的都已经该戳
                            的都戳了。
Leetcode----------322. 零钱兑换
                            典型的dp
328
Leetcode----------338. 比特位计数
Leetcode----------343. 整数拆分
                            （同剑指offer第14题）
Leetcode----------344. 反转字符串
                            （就首位反转啊）
Leetcode----------345. 反转字符串中的元音字母
                        (双指针的移动，一定要自己写，注意边界)  记录两个写法
347  重点提 2个方法 堆和hash 但是由于普通的堆是比较大小，这里需要记录频次，因此需要重新设计。
349  方法比较多，这里记录的只是set，还有排序的
350  和349一起学习
365（跳过）
378  方法比较多，堆排序，二分
Leetcode----------383. 赎金信
                          （桶计数，可以开辟一个数组，也可以开辟两个。还可以排序后双指针。但这里只记录数组）
                          （数组就是hash了。一个道理）
Leetcode----------387. 字符串中的第一个唯一字符
                            （剑指offer上也有本题原题）(记录两个方法，也注意和博客上的进行对比)(第2种方法是自己敲的)
389  异或和桶计数
Leetcode----------392. 判断子序列
Leetcode 404   -----左叶子之和（关键是找准递归的时候，该加到sum的条件，是三个都满足）（只记录递归，非递归的方式不好写）
                        （非递归是存放的不是节点，需要加入条件，用到一个类，包装多个信息）
Leetcode----------409. 最长回文串
                            本题计算所有字母个数，最多只允许一个字母的次数为奇数
Leetcode----------413. 等差数列划分
                        本来可以用二维数组，但是很巧妙，一维的就可以。二维的直接求结果，一维的再用个sum
                        且二维数组需要斜着填，反正我自己思路这样，但是不会写
                         dp_num[i]=dp_num[i-1]+1;
                                        sum+=dp_num[i];  用这两句代替二维数组
414   本题可以不用堆排序，直接3个变量
Leetcode----------415. 字符串相加
                            用一个数来记录进位，和67的代码中的非常像，改动两行就出来了。 这里记录两个方法吧
                               建议使用第一个方法的写法，第二个方法的边界不太容易想到，最后一次进位仍然进入了循环。
Leetcode 437   -----路径总和 III（妈的这就不是一道简单题，难题好吗。什么前缀和，双重递归 后续看题频了）
Leetcode----------445. 两数相加 II
                            不让翻转，那必须是栈
448
455
Leetcode----------459. 重复的子字符串
            子序列：一个给定的序列的子序列是在该序列中删除若干元素后得到的序列；
            子串：字符串中任意个连续的字符组成的子序列称为该串的子串。
                    （又是一题可以利用s1+s2的题，和面试题0109异曲同工之妙）(再记录一种普通方法，更加对面试官的胃口的)
                    (substring有坑，本题慎重使用，调了半天出不来，纯暴力是O(n^3))
461  异或 无进位相加
Leetcode----------486. 预测赢家
                        （本题同877题，但建议用本题记录的写法，因为更容易理解过程，注意是从下往上，从左往后的遍历）
496先遍历大数组nums2，首先将第一个元素入栈；
   继续遍历，当当前元素小于栈顶元素时，继续将它入栈；当当前元素大于栈顶元素时，栈顶元素出栈，
   此时应将该出栈的元素与当前元素形成key-value键值对，存入HashMap中；
   当遍历完nums2后，得到nums2中元素所对应的下一个更大元素的hash表；
   遍历nums1的元素在hashMap中去查找‘下一个更大元素’，当找不到时则为-1。
Leetcode 501  -----二叉搜索树中的众数（本题可以中序遍历后，转为求有序数组中出现次数最多的元素，但由于进阶要求降低空间复杂度）
                            因此，在中序遍历的过程中，就进行频次统计，由于是中序，每次遍历就相当于从有序数组中拿一个元素出来。
                            （仅记录非递归做法，非递归也可以做，这里不记录，后续看题频了）
                            （本题不算简单题了，但看懂代码也知道不难）
509
Leetcode----------516. 最长回文子序列
                            行从下往上，列从左往右
                                             if(s.charAt(i) == s.charAt(j)){
                                                dp[j][i] = dp[j+1][i-1] + 2;
                                            }else{
                                                dp[j][i] = Math.max(dp[j+1][i],dp[j][i-1]);
                                            }
Leetcode----------520. 检测大写字母
                                (第一种抄的，第二种我自己写的)
Leetcode----------521. 最长特殊序列 Ⅰ
                                    （这种题目没有什么意义）
Leetcode 530  -----二叉搜索树的最小绝对差（3种思路，整体思想是中序，1.用数组中序后逐个比较  2.在中序递归时直接比较，并更新）
                       (3.中序非递归写法)(12记录在一个solution)
                       ！！！！！那种递归前面加变量等于的，需要加强学习，找到规律，本题是没有加等于，直接裸递归。
Leetcode 538  -----把二叉搜索树转换为累加树(先遍历右子树，并逐个求和，向上返回时，进行累加)
                        （同样两个写法，不过非递归的栈是中序写法！！！）(本题的中序和897的中序写法稍微不同 if和while的区别)
Leetcode----------541. 反转字符串 II
                      (记录一种笨方法，但是很直观的)
542
Leetcode 543  ----- 二叉树的直径   (就是求左右子树的最大深度，然后相加，这个结果用一个全局变量更新即可)
Leetcode----------551. 学生出勤记录 I
                            （边界条件放前面）
Leetcode----------557. 反转字符串中的单词 III (剑指offer上58.1类似)（腾讯面试过）
                     （两个思路，1.利用栈，碰到空格，就弹出顺序添加到string中
                     2.利用双指针，碰见空格后，从后向前添加）
                      （这里记录第2种）(自己写出来了，妈的)（当然方法1中的也可以用交换的方法来做）
Leetcode 559  -------N叉树的最大深度(2种写法，递归非递归，其中非递归又分两种写法，之前104和offer55-1分别记录了非递归的一种
                                        这里将两个方法都收录了)(solution2和3都容易理解，但2更偏向于在考场上相到)
                                        同样，本题也可以使用栈，但是栈中要记录节点的深度，所以需要新建类，毕竟麻烦

560  本题如果没有负数，应该是可以用滑动窗口的 还有个hashmap的方法，这里没看懂，因为要调用map的其他方法map.getOrDefault(sum, 0)
Leetcode----------561. 数组拆分 I
                            排序，然后取奇数位相加  还有空间换时间的，但是没看懂
Leetcode 563  -----二叉树的坡度（典型的后续遍历，求左边，求右边再整合）(貌似就这一种写法？)
Leetcode 572  -----另一个树的子树（参考100题 相同的树，如果是左子树还是右子树还是从根结点相同，两个递归调用即可）
                            当然也可以写成非递归  本题记录两个写法吧 递归和非递归   注意写法稍微有点不同。
Leetcode 589   -------N叉树的前序遍历(和590联系)（两种，递归和非递归的栈，不能用队列层次遍历）
Leetcode 590   -------N叉树的后序遍历(只有递归、非递归用栈的深度遍历两种方式，层序遍历不能用了)（4个solution3个写法）
                                        (注意，后序递归有两个写法，两个栈，或者用数组，总之就是为了记录顺序)
605
Leetcode 606   -----根据二叉树创建字符串(不会写，但是摘录的代码和我的思路最像，但是有点难理解)
Leetcode 617.   -------合并二叉树(方法1：非递归队列 方法2：非递归栈 方法3：递归)
Leetcode 637  ------二叉树的层平均值（依旧是32-2这种遍历层次的题目，每一层遍历完后求平均值）（将32-2的两个写法均改写）
Leetcode----------646. 最长数对链（本题有很多类似题）
                         if(pairs[i][0]>pairs[j][1]){
                                dp[i]=Math.max(dp[i],dp[j]+1);
Leetcode----------647. 回文子串
                        （本题是个重点题  两种方法，一个是动态规划，一个是中心扩展）
Leetcode 653  -----两数之和 IV - 输入 BST(首先本题和Leetcode第1题特别像 1.中序遍历，放在list中，由于有序，可以双指针
                        方法2.参考第1题两数之和，可以用hashset集合存值，然后遍历寻找。掌握这两个常规写法即可)
                        吾日三省吾身，中序非递归会了吗。
Leetcode 654  ----- 最大二叉树（只记录一种方法 递归）
                            （注意边界条件）
Leetcode----------657. 机器人能否返回原点
                                (就是上和下相等，左和右相等)
Leetcode 669   -----修剪二叉搜索树（只记录一种递归方法）（写法和68-2特别像，希望能掌握这种思想）（备注：根据题频掌握）
                        （这题和上一提都还要反复看）
Leetcode 671  -----二叉树中第二小的节点（本题好像官方测试用例有问题，后续看题频了，方法还是比较容易看懂的）
Leetcode----------680. 验证回文字符串 Ⅱ
Leetcode 687 ----- 最长同值路径（此题并不简单  留作以后来看）
Leetcode----------695. 岛屿的最大面积
                            典型的深度dfs
Leetcode----------696. 计数二进制子串
                                （指针不断后移的更新）(思路没有理清，直接看的代码，选的这个代码思路就是对我胃口的)
Leetcode 700   -------二叉搜索树中的搜索（难得自己直接做出来了）（递归非递归两个写法）
Leetcode----------709. 转换成小写字母   (小写字符的数字更大 大32)
                            （本题涉及Ascii码的大小写）（两个写法，遍历方式不同）
Leetcode----------712. 两个字符串的最小ASCII删除和
                            和最长公共子串有点联系，但也不完全是，在子串尽量长的情况下，使得码表最大
                            典型的二维表，一行一列为初始化，然后慢慢填。
Leetcode----------714. 买卖股票的最佳时机含手续费
                            （有点东西）
718  dp也可以窗口，但是稍微复杂一点
Leetcode----------739. 每日温度
                      本题有多个方法，记录2~3个
Leetcode----------740. 删除与获得点数
                            (这题看评论，可以和198打家劫舍对应起来)
746
Leetcode----------771.宝石与石头
Leetcode 783   -----二叉搜索树节点最小距离（本题和第530题的思路完全一样，代码也一样，将530代码拷过来了）
Leetcode----------788. 旋转数字
                                （记录了一种比较巧的思想，没有那么多的讨论,但是分类分的很巧）
                                   （包含其他字符的都是false，只要包含了一个指定字符的，就是正确的字符）
Leetcode----------804. 唯一摩尔斯密码词
                                （就是看翻译之后有多少种方式，  给定n个单词，翻译出来的结果少于n个）
                            (这里都是小写，所以减去a即可)(或者减32)
Leetcode----------820. 单词的压缩编码（跳过了，这题和前缀树有关，如果有机会，回来看看）
Leetcode----------824. 山羊拉丁文
                       （先记录一种用split分割的方法吧。值得一看，然后后续看题频了，这题也是个有空格啊，单
                          词计数的题，参考我自己写1455的代码。）
Leetcode----------832. 翻转图像
                            （没做出来，注意边界）
Leetcode----------836. 矩形重叠
                            本题需要逆向考虑，考虑不重叠的时候排除在外即可。这样代码就比较简练
Leetcode 872  -----叶子相似的树(其实就是遍历出所有的叶子节点，然后比较。而想拿到叶子节点，就是深度遍历。可以用数组存，也可以
                            用字符串存)（这里记录两个方法 1.递归  2.非递归栈前序遍历用数组记录）
Leetcode----------876. 链表的中间结点
Leetcode----------877. 石子游戏
                                最终得到转移方程     pile是原数组。
                                用d[i][j]表示从i到j这一段数组，先手的人比后手的人能多多少（负数表示少的最少情况）
                                因此，dpij表示从i到J,能赢多少分，等于取i时的情况和取j时的情况取最大值
                                而取i的情况，就是当前i的值，减去从i+1到j时能赢多少分，因为你取了i，先手就交换了，剩下
                                的相当于是你先取了i，接下来将会输多少分（从I+1到j，因为别人会在这个区间赢回最大值）
                                因此是做减法
                                dp[i][j] = max { pile[i] - dp[i+1][j] , pile[j] - dp[i][j-1] }
Leetcode----------892. 三维形体的表面积
Leetcode 897   ------递增顺序查找树（注意，本题是中序遍历，参考offer54题的中序）
                        (递归和非递归以及用数组存3种写法，但只记录前两种，用数组记录的方法增加了空间复杂度，且时间复杂度相同)
905 双指针
912  会写常见的几个排序 ，归并，快排和堆排！
Leetcode---------- 914. 卡牌分组
                            桶计数，然后看最大公约数，辗转相除
Leetcode----------917. 仅仅反转字母
                          (逻辑就是双指针交换，跳过非字母符号)
                          （一定要注意，逻辑怎么写的，小写字母码更多）（2个方法）
Leetcode----------929. 独特的电子邮件地址
                             (本题刚开始想的是，遍历，然后存hashmap，碰到+就跳过，然后map中记录次数。
                             后来发现其实set就行，并且学习别人的思路，字符串还得多看别人怎么写的)
                                （记录两种写法，有点东西的）（split分割，substring 从某个索引往后截取）
Leetcode----------931. 下降路径最小和
                            两边的边界和中间的情况
Leetcode 938     -------二叉搜索树的范围和
                            (这个题字面含义很难理解，本意就是求出所有 X >= L 且 X <= R 的值的和)
                            (方法1：中序遍历放数组再求和。方法2：递归，某个节点值大于L,就左右都递归，满足时加到sum
                             ,小于R，也是左右都递归，而出现小于L时，就一直向右子树递归，出现大于R时，就往左树递归，方法3：栈
                             方法4：栈）
                            注意，调用某个递归的时候，一定要返回。且ArrayList中的是get size。不是length
Leetcode----------945. 使数组唯一的最小增量
                            记录两个写法，其中一个是优化的计数版本
947 和k的整数倍的数组，貌似字节考了，但是不会做
Leetcode 965    ------单值二叉树（多种写法啊，就是在遍历树的时候判断一下值是否与根节点相同即可）
Leetcode----------977. 有序数组的平方
                            （双指针，从后往前比较）
Leetcode----------983. 最低票价
                            倒着来推，很巧妙
Leetcode 993  -----二叉树的堂兄弟节点（其实思路很简单，利用层序遍历，只需要比较是否在同一层，可以用变量深度来记录，然后记录
                        节点的父节点，然后比较父节点即可）（自己看着别人的改出来了，但实际上不难）（2中层序非递归均改写了）
Leetcode----------994. 腐烂的橘子
                        （第一次接触到图论的题，很牛批啊）
Leetcode----------999. 可以被一步捕获的棋子数（非重点题）

Leetcode----------1013. 将数组分成和相等的三个部分
                                看和能否分成三等分，然后左右两个指针向中间逼近，看能否有数组满足情况,也可以直接从正面加
                                加出两个结果也正确了。这里记录两个写法,双指针的在逻辑上稍微绕一点，但是整体要好一点
                                第二个写法稍微有点问题。
1014
1021
Leetcode 1022  -----从根到叶的二进制数之和（本题可以有257题遍历过后，由字符串转为数字，然后求和，也可以由在遍历过程中直接算
                            但没必要在遍历后再转，直接算就好了）(写法1根据257题解法1改写，记录两个类似的写法，其他的不收录)
                        （这里提一下，257的不回溯写法，也不止一种）
Leetcode----------1025. 除数博弈
                            java boolean数组默认false
                            动态转移方程就是，给某个数，我能否找到一个使先手输的，这样我先取了后，后手作为剩下的先手
                            一定会输，如果找不到，那么我就输了。

1046
Leetcode----------1051. 高度检查器
                            (可以排序，但是桶计数更佳，但是桶计数没有想到，这就是个问题)
Leetcode----------1071. 字符串的最大公因子
                          （求最大公因子，辗转相除）（这题也不太可能出现在面试和笔试中，因此只记录一个写法）
1095  本题和153对比起来看
Leetcode----------1103. 分糖果 II
Leetcode----------1108. IP 地址无效化
                            (就是一个替换操作)
1111
1122
Leetcode----------1143. 最长公共子序列
                             "ace" 是 "abcde" 的子序列,所以本题容易想到
Leetcode----------1160. 拼写单词
                            看懂题意，给的字符串中对于每个字符数组中的每个元素都只能用一次。即 abc,abd和 acbde，在比较
                            abc时只用一次可以，在abd时也只用一次也可以。
                                值得注意的是，java每次用之前统计的数组，都需要拷贝一份，不能用原数组
1162
Leetcode----------1189. “气球” 的最大数量
                        (桶排序的思想，记录次数，然后比较最小值)
Leetcode----------1221. 分割平衡字符串
                                (自己做出来了哦)
Leetcode----------1227. 飞机座位分配概率
                                概率题，画画图就知道，n大于1的时候，都是1/2，因此当某个人自己位置有的时候，他一定坐自己的
                                没必要分析动态规划啊。
1248
Leetcode----------1266. 访问所有点的最小时间
                                （找规律，分情况讨论）
Leetcode----------1277. 统计全为 1 的正方形子矩阵
                            主要还是要理解动态规划的公式      dp是当前某个位置，所有的正方形种类的个数
                            dp[i][j] = min(dp[i-1][i],dp[i][j-1],dp[i-1][j-1])
Leetcode----------1289. 下降路径最小和  II
                                记录的n^3的写法，有优化的版本，就是每次用两个变量记录最大和次大的值
1290
Leetcode----------1295. 统计位数为偶数的数字
                            （看这个数能被10整除多少次）
Leetcode----------1299. 将每个元素替换为右侧最大元素
Leetcode----------1304. 和为零的N个唯一整数
                                （过于简单）
Leetcode----------1309. 解码字母到整数映射
                                （题目不算难，码表的转换是否加强后续看题频吧）
Leetcode----------1313. 解压缩编码列表
                                （可以用arrayslist，也可以先遍历一遍，求数组的长度，这里选用第二种写法）
                            (有点东西的，第二次遍历添加的时候  自己居然没搞出来)
1323
Leetcode----------1332. 删除回文子序列
                            （妈的，这是道脑筋急转弯，不用看了）
Leetcode----------1351. 统计有序矩阵中的负数
                            （本题由mn的本方法可以变成二分法，再变成o(n)级别，本题记录时间复杂度最低的）
Leetcode----------1365. 有多少小于当前数字的数字
                          本题的方法没有想对      暴力法O(n^2) 和桶计数
Leetcode----------1370. 上升下降字符串
                       （用桶排序就容易理解，26个桶，每个桶统计出现的次数，每添加一个字符，对应桶就减一）
Leetcode----------1374. 生成每种字符都是奇数个的字符串
Leetcode 1379 ----- 找出克隆二叉树中的相同节点
Leetcode----------1380. 矩阵中的幸运数
                                两个数组比较，然后分别记录行和列的最大，然后比较对应的角标是否相等。
Leetcode----------1385. 两个数组间的距离值
                            跳过，题意很难理解
Leetcode----------1389. 按既定顺序创建目标数组
                                (分析在哪插入)
Leetcode----------1402. 做菜顺序
                        (排序后，从后往前加 两个变量)
Leetcode----------1417. 重新格式化字符串
                            我想复杂了，想用多个数组，然后添加一个数量减少一个。其实一个字符数组，一个数字数组就可以了。
       两次遍历就可形成，然后用两个指针指着来就行。 （大佬们都是用一个数组，前半部分放字母，后面放数字，但是要排序）
      （但是本题其实也是可以用数组内部不断交换来判断的，c语言的同学都是交换的，所以本题不做重点，记录一种写法即可，后续看需求）
Leetcode----------1422. 分割字符串的最大得分
                            （本来是三遍扫描，但是在第二遍和第三遍可以合并起来处理）
                            （一定要注意边界，是j和j-1的相加）
Leetcode----------1431. 拥有最多糖果的孩子
                            （先遍历一遍取最大值，再遍历一遍加上数，看是否大于）
Leetcode----------1436. 旅行终点站
                            （目的地不出现来出发地的时候，此时的目的地就是重点）
Leetcode----------1446. 连续字符
                                （快慢指针）（自己纯手打了）
Leetcode----------1450. 在既定时间做作业的学生人数(超级简单)
Leetcode----------1455. 检查单词是否为句中其他单词的前缀
                                （常规思路，三个指针比较，两个指向句子单词收尾，一个指向要比较的前缀
                                非常规思路，调用各种函数。）（本题题解和评论较少，因此常规笨方法就不实现了）
                            这题不就是项目中的前缀树的题吗。还是只用比较1个的没符号的简单版本

                            妈的 我是真的强，搞了几个小时，1455搞出来了。
                            过几天再来看，补上注释
Leetcode----------1460. 通过翻转子数组使两个数组相等
                                (桶计数)
Leetcode----------1464. 数组中两元素的最大乘积
                                （扫描时更新）


7.5




