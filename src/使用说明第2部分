分类刷题（即使是同一道题，在不同的时候刷的，方法一样，但写法不同）
    第一部分 树
5.20
1.剑指offer27题    -------二叉树的镜像（3种解法，递归，队列，栈）
                                注意是输出镜像，所以可以直接把树给改掉，而不是生成一个镜像再输出。
2.面试金典04.02.   -------最小高度树（1种解法，二分递归）
3.剑指offer55-1题  -------二叉树的深度（3种写法，递归，非递归层次，非递归深度，只记录了前两种！！！！）
                                （层次用队列，深度用栈，本题的栈要存节点以及当前节点的深度才行即新建一个类）
--------------------------------------------------------------------------------------------------------------
5.21
1.Leetcode 938     -------二叉搜索树的范围和
                            (这个题字面含义很难理解，本意就是求出所有 X >= L 且 X <= R 的值的和)
                            (方法1：中序遍历放数组再求和。方法2：递归，某个节点值大于L,就左右都递归，满足时加到sum
                             ,小于R，也是左右都递归，而出现小于L时，就一直向右子树递归，出现大于R时，就往左树递归，方法3：栈
                             方法4：栈）
                            注意，调用某个递归的时候，一定要返回。且ArrayList中的是get size。不是length
2.Leetcode 617.   -------合并二叉树(方法1：非递归队列 方法2：非递归栈 方法3：递归)
3.Leetcode 226.   -------翻转二叉树-------(同剑指offer第27题)
4.Leetcode 590   -------N叉树的后序遍历(只有递归、非递归用栈的深度遍历两种方式，层序遍历不能用了)（4个solution3个写法）
                                        (注意，后序递归有两个写法，两个栈，或者用数组，总之就是为了记录顺序)
5.Leetcode 700   -------二叉搜索树中的搜索（难得自己直接做出来了）（递归非递归两个写法）
--------------------------------------------------------------------------------------------------------------
5.22
1.Leetcode 104   -------二叉树的深度(同剑指offer第27题)（本题的队列写法和27题中记录的不同）
2.Leetcode 589   -------N叉树的前序遍历(和590联系)（两种，递归和非递归的栈，不能用队列层次遍历）
3.剑指offer54题  -------二叉搜索树的第k大节点(牛客上是第k小的节点，一个是从头，一个是从尾)
                            (方法1,递归加数组还有优化的，当size变为k时就停止，见牛客的博客)（方法2和3都是对遍历的计数
                            只不过一个递归一个非递归的栈，且本题是深度中序的非递归，唯一要修改的就是在中序遍历的时候进行计数）
4.Leetcode 108  -------将有序数组转换为二叉搜索树(同面试金典04.02)（本次的边界条件和金典中记录的不同，是根据我的习惯的边界）
5.Leetcode 559  -------N叉树的最大深度(2种写法，递归非递归，其中非递归又分两种写法，之前104和offer55-1分别记录了非递归的一种
                                        这里将两个方法都收录了)(solution2和3都容易理解，但2更偏向于在考场上相到)
                                        同样，本题也可以使用栈，但是栈中要记录节点的深度，所以需要新建类，毕竟麻烦
--------------------------------------------------------------------------------------------------------------
5.23
1.剑指offer32-2题   ----从上到下打印二叉树 II(本题基本上就是队列)（和层序遍历求深度相似）(根据求深度的两个队列写法而改写。2种)
2.Leetcode 897   ------递增顺序查找树（注意，本题是中序遍历，参考offer54题的中序）
                        (递归和非递归以及用数组存3种写法，但只记录前两种，用数组记录的方法增加了空间复杂度，且时间复杂度相同)
3.剑指offer68-1题 ------二叉搜索树的最近公共祖先（没最做出来啊，主要是规律要找对，这个是二叉搜索树）
                            （本题规律就是，对于公共祖先，要求两个节点一个在左树，一个在右树）
4.Leetcode 965    ------单值二叉树（多种写法啊，就是在遍历树的时候判断一下值是否与根节点相同即可）
5.剑指offer68-2题 ------二叉树的最近公共祖先（还是没最做出来啊，这个不是二叉搜索树）
                            这里记录两种方法，递归和递归比较路径。（方法1掌握，方法2是递归回溯，有难度。根据题频掌握）
6.Leetcode 669   -----修剪二叉搜索树（只记录一种递归方法）（写法和68-2特别像，希望能掌握这种思想）（备注：根据题频掌握）
                        （这题和上一提都还要反复看）
--------------------------------------------------------------------------------------------------------------
5.24
1.Leetcode 107   ------二叉树的层次遍历 II（和剑指offer32-2题，104题类似。一个从上到下，一个从下到上）（只不过要反转一下）
                        （考虑链表的反转或者数组的反转，可以使用的是头插法，链表的翻转写法，以及栈的使用，这里记录了一种用栈
                        的方法，其实考虑层次遍历的写法都不止一种，如32-2中的记录两个写法都可以改变成其他写法）
2.Leetcode 637  ------二叉树的层平均值（依旧是32-2这种遍历层次的题目，每一层遍历完后求平均值）（将32-2的两个写法均改写）
3.Leetcode 257  -----二叉树的所有路径(典型的深度遍历，或者说是和图的深度遍历一样，不能出现相同的元素，需要回溯)
                         （虽然说回溯有非递归写法，但一般都用递归写）（这里记录两个方法，1.不使用回溯。2.使用回溯）(没做出来)
                         （因为普通的树的深度遍历递归写法，由于字符串类型在不new对象的时候，是值传递，所以可以边遍历边添加）
                         （所以方法2中使用StringBuider时，是必须要回溯，因为改动一次后，就会一直变动）
                         （a方法中的String和StringBuilder在调用b方法修改了String和StringBuider后，返回，那么String并不会变动
                         而StringBuilder变动了，因此a可以再调到c传入的还是String，而在调c方法还想传入之前的Buider就必须回溯）
                         其中solution1提供2中写法，建议学会第二种
4.Leetcode 235  -----二叉搜索树的最近公共祖先(同剑指offer68-1题 剑指用了两个方法，这里就记录一个吧)
5.Leetcode 1022  -----从根到叶的二进制数之和（本题可以有257题遍历过后，由字符串转为数字，然后求和，也可以由在遍历过程中直接算
                            但没必要在遍历后再转，直接算就好了）(写法1根据257题解法1改写，记录两个类似的写法，其他的不收录)
                        （这里提一下，257的不回溯写法，也不止一种）
6.Leetcode 872  -----叶子相似的树(其实就是遍历出所有的叶子节点，然后比较。而想拿到叶子节点，就是深度遍历。可以用数组存，也可以
                            用字符串存)（这里记录两个方法 1.递归  2.非递归栈前序遍历用数组记录）
7.Leetcode 538  -----把二叉搜索树转换为累加树(先遍历右子树，并逐个求和，向上返回时，进行累加)
                        （同样两个写法，不过非递归的栈是中序写法！！！）(本题的中序和897的中序写法稍微不同 if和while的区别)
8.面试金典17.12  -----BiNode（居然没看出来。这是和897题是一样的，也没做出来）（）
                            （本题题干描述和897稍微不同，但是还是按897来学习，如果后续出现再自己看）
9.剑指offer55-2  -----判断二叉树是否平衡（我的博客记录了两三个方法，全局变量，中间计算，和全局变量的中间计算）
                        （建议使用全局变量的方法） 这里记录的都是全局变量的写法。
10.Leetcode 100  -----相同的树(递归自己做出来的)（当然可以有其他的非递归写法，就是遍历一个节点比较一次。层序和深度均可以）
                        (就是所有的遍历写法都可以，只是加上值的比较)（这里是只记录了递归和深度遍历非递归）
                        （我改写的可能不健壮
                        参考剑指offer第28题，可能需要加几行代码）
--------------------------------------------------------------------------------------------------------------
5.25
1.剑指offer 28  ----- 对称的二叉树（写法和100题非常相似，尤其是递归过程，几个boolean类型的并列。其实就是左右子树对应的相等
                        逻辑稍微有点相反）(高度参考第100题，只是对比的时候左比左变成了左比右)（但是本题要注意的是，100题的
                        深度非递归记录的两种写法，第一种可以稍微改改就行，第二种也就是根据我的思路改的，还需要再添加几行代码）

2.Leetcode 530  -----二叉搜索树的最小绝对差（3种思路，整体思想是中序，1.用数组中序后逐个比较  2.在中序递归时直接比较，并更新）
                       (3.中序非递归写法)(12记录在一个solution)
                       ！！！！！那种递归前面加变量等于的，需要加强学习，找到规律，本题是没有加等于，直接裸递归。
3.面试金典04.04  -----检查平衡性（同剑指offer55-2）
                        ！！！！！本题就是加变量等于的，这是因为，我们不仅仅是遍历，而是想拿到子树的信息时，并做一个整合
                        所以是要加变量等于递归过程，从而整合信息。
4.Leetcode 563  -----二叉树的坡度（典型的后续遍历，求左边，求右边再整合）(貌似就这一种写法？)
5.Leetcode 653  -----两数之和 IV - 输入 BST(首先本题和Leetcode第1题特别像 1.中序遍历，放在list中，由于有序，可以双指针
                        方法2.参考第1题两数之和，可以用hashset集合存值，然后遍历寻找。掌握这两个常规写法即可)
                        吾日三省吾身，中序非递归会了吗。
6.Leetcode 437   -----路径总和 III（妈的这就不是一道简单题，难题好吗。什么前缀和，双重递归 后续看题频了）
7.Leetcode 404   -----左叶子之和（关键是找准递归的时候，该加到sum的条件，是三个都满足）（只记录递归，非递归的方式不好写）
                        （非递归是存放的不是节点，需要加入条件，用到一个类，包装多个信息）
8.Leetcode 606   -----根据二叉树创建字符串(不会写，但是摘录的代码和我的思路最像，但是有点难理解)
9.Leetcode 783   -----二叉搜索树节点最小距离（本题和第530题的思路完全一样，代码也一样，将530代码拷过来了）
10.Leetcode 110  -----平衡二叉树（同面试金典0404 同剑指offer 55-2）（代码直接拷过来了）
11.Leetcode 270(会员才能解锁)
12.Leetcode 993  -----二叉树的堂兄弟节点（其实思路很简单，利用层序遍历，只需要比较是否在同一层，可以用变量深度来记录，然后记录
                        节点的父节点，然后比较父节点即可）（自己看着别人的改出来了，但实际上不难）（2中层序非递归均改写了）
13.Leetcode 101  -----对称二叉树 （本题是镜像二叉树 和剑指offer28题一样  判断树是否对称  而剑指offer27则是反转二叉树）
                            (本题又是个return中几个一起的，因为是子问题加根都要满足条件，所以并列）(3个方法)
                            （注意还有非递归的写法  并且虽然只记录了栈，其实也可以用队列 ）（本题新增加记录了队列方法）
14.Leetcode 543  ----- 二叉树的直径   (就是求左右子树的最大深度，然后相加，这个结果用一个全局变量更新即可)
--------------------------------------------------------------------------------------------------------------
5.26
1.Leetcode 112  -----路径总和(递归好写，迭代不好写，需要在栈中压入当前的sum。)（我记录的solution2是不能通过的示例）
2.Leetcode 572  -----另一个树的子树（参考100题 相同的树，如果是左子树还是右子树还是从根结点相同，两个递归调用即可）
                            当然也可以写成非递归  本题记录两个写法吧 递归和非递归   注意写法稍微有点不同。
3.Leetcode 671  -----二叉树中第二小的节点（本题好像官方测试用例有问题，后续看题频了，方法还是比较容易看懂的）
4.Leetcode 501  -----二叉搜索树中的众数（本题可以中序遍历后，转为求有序数组中出现次数最多的元素，但由于进阶要求降低空间复杂度）
                            因此，在中序遍历的过程中，就进行频次统计，由于是中序，每次遍历就相当于从有序数组中拿一个元素出来。
                            （仅记录非递归做法，非递归也可以做，这里不记录，后续看题频了）
                            （本题不算简单题了，但看懂代码也知道不难）
5.Leetcode 111  ----- 二叉树的最小深度(直接从最大深度改为Min容易翻车 翻车案例[1,2]的深度是2不是1)（因此需要添加一下判断条件）
6.Leetcode 687 ----- 最长同值路径（此题并不简单  留作以后来看）
---------------------------------------------
树的49道简单题做了46道，下面将展开中等题的学习
7.Leetcode 1379 ----- 找出克隆二叉树中的相同节点
8.面试金典0403  ----- 特定深度节点链表（层序遍历 同剑指offer32-2题 ）（之前的层序遍历和深度有关的都是两个写法，本题也是一样
                        唯一不同就是本题是用链表来做的，因此只记录一个写法）(本题多出来的就是一个链表的使用)
9.Leetcode 654  ----- 最大二叉树（只记录一种方法 递归）
                            （注意边界条件）
--------------------------------------------------------------------------------------------------------------
注：牛客网答疑时，写了一个前中序确定二叉树的





